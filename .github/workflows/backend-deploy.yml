# GitHub Actions Workflow File - Complete Learning Guide with Inline Comments
# This file defines an automated CI/CD pipeline that runs on GitHub's servers
# When you push code, it automatically builds, tests, and deploys your backend

name: Deploy Backend to EC2  # Display name shown in GitHub Actions UI

on:  # WHEN does this workflow run? (triggers section)
  push:  # Trigger on git push events
    paths:  # Only run when these files/folders change (path filters)
      - 'backend/**'  # Any file in backend/ folder
      - '.github/workflows/backend-deploy.yml'  # This workflow file itself
      - 'backend/Dockerfile'  # Docker build instructions
      - 'backend/requirements.txt'  # Python dependencies
      - 'backend/.env*'  # Environment variable files
      - '!frontend/**'  # EXCLUDE frontend changes (don't run for frontend)
    branches:  # Only run on pushes to these branches
      - main  # Production branch

jobs:  # WHAT jobs to run (can have multiple jobs, but we have one)
  deploy:  # Job name (unique identifier for this job)
    runs-on: self-hosted  # Run on YOUR EC2 server (not GitHub's servers)

    steps:  # STEPS to execute (run in order - like a recipe)

      - name: Checkout code  # Step 1: Get the code from GitHub (human-readable step name)
        uses: actions/checkout@v4  # Use GitHub's pre-built "checkout" action (version 4)

      - name: Create environment file  # Step 2: Create environment variables file
        run: |  # Multi-line shell script (pipe | means multi-line)
          cd /home/ec2-user/portfolio/backend
          cat > .env << EOF
          MONGO_URL=${{ secrets.MONGO_URL }}
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
          SERPER_API_KEY=${{ secrets.SERPER_API_KEY }}
          CORS_ORIGINS=${{ secrets.CORS_ORIGINS }}
          CHROMA_HOST=${{ secrets.CHROMA_HOST }}
          CHROMA_API_KEY=${{ secrets.CHROMA_API_KEY }}
          CHROMA_TENANT=${{ secrets.CHROMA_TENANT }}
          CHROMA_DATABASE=Development
          CLOUDINARY_CLOUD_NAME=${{ secrets.CLOUDINARY_CLOUD_NAME }}
          CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}
          DB_NAME=portfolioDB
          ENVIRONMENT=production
          RESEND_KEY=${{ secrets.RESEND_KEY }}
          RESEND_API_KEY=${{ secrets.RESEND_KEY }}
          TO_EMAIL=${{ secrets.TO_EMAIL }}
          EOF
          chmod 600 .env  # Set file permissions (owner read/write only)

      - name: Repopulate ChromaDB (if data files changed)  # Step 3: Update vector database if portfolio data changed
        run: |  # Multi-line shell script
          cd /home/ec2-user/portfolio/backend  # Go to backend folder on EC2
          if git diff HEAD~1 HEAD --name-only | grep -E "(portfolio_data\.json|formatted_data\.json|fixed_data\.json)"; then  # Check if data files changed in last commit
            echo "Data files changed - repopulating ChromaDB..."  # If files changed, show message
            python3 populate_vector_db.py  # Run the database population script
            echo " ChromaDB repopulated successfully!"  # Success message
          else  # If no data files changed
            echo " No data file changes detected - skipping ChromaDB repopulation"  # Skip message
          fi  # End of if statement

      - name: Kill process on port 8000
        run: |
          PID=$(sudo lsof -ti:8000 || true)
          if [ -n "$PID" ]; then
            sudo kill -9 $PID
            echo "Killed process $PID on port 8000."
          else
            echo "No process found on port 8000."
          fi
          exit 0

      - name: Deploy and restart backend  # Step 4: Build and deploy the Docker container
        run: |  # Multi-line shell script
          cd /home/ec2-user/portfolio  # Go to project root on EC2
          git fetch origin main  # Get latest changes from GitHub
          git reset --hard origin/main  # Force update to latest commit (destructive!)
          
          # 1. Build the NEW image first (While the old one is still running!)
          # Enable BuildKit for faster builds
          export DOCKER_BUILDKIT=1
          sudo -E docker build -t portfolio-backend:new -f backend/Dockerfile .
          
          # 2. Stop and remove the old container (Downtime starts here - only <5 seconds)
          sudo docker rm -f portfolio-backend || true
          
          # 3. Rename tagged image to latest
          sudo docker tag portfolio-backend:new portfolio-backend:latest
          
          # 4. Start the new container
          sudo docker run --env-file /home/ec2-user/portfolio/backend/.env -p 8000:8000 --name portfolio-backend --restart unless-stopped -d portfolio-backend:latest
          
          # 5. Clean up dangling images to save space
          sudo docker image prune -f

      - name: Wait for container to start  # Step 5: Wait for container to start up
        run: |  # Multi-line shell script
          echo "Waiting for container to start..."  # Status message
          sleep 10  # Wait 10 seconds for container to initialize
          sudo docker logs portfolio-backend --tail 50  # Show last 50 lines of container logs

      - name: Health check  # Step 6: Test that the backend is working
        run: |  # Multi-line shell script
          echo "Running health check..."  # Status message
          max_attempts=10  # Try up to 10 times
          attempt=0  # Start attempt counter at 0
          while [ $attempt -lt $max_attempts ]; do  # Loop while attempts < max
            if curl -f http://localhost:8000/ > /dev/null 2>&1; then  # Try to curl the health endpoint
              echo " Backend is healthy!"  # If curl succeeds (HTTP 200)
              exit 0  # Success - exit the script
            fi  # End of if
            echo "Attempt $((attempt+1))/$max_attempts failed, retrying..."  # Failure message with attempt count
            sleep 5  # Wait 5 seconds before retrying
            attempt=$((attempt+1))  # Increment attempt counter
          done  # End of while loop
          echo " Backend health check failed!"  # If all attempts failed
          exit 1  # Failure - stop the workflow

      - name: Tag Docker image for registry  # Step 7: Tag the Docker image for registry (only runs if health check passed)
        run: |  # Multi-line shell script
          echo " Tagging image for registry..."  # Status message
          COMMIT_SHA=$(git rev-parse --short HEAD)  # Get short commit hash for unique versioning
          IMAGE_TAG="kubealthaf/portfolio-backend:${COMMIT_SHA}"  # Unique tag with commit
          LATEST_TAG="kubealthaf/portfolio-backend:latest"  # Latest tag for easy pulling
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV  # Save for next steps (GitHub environment variable)
          echo "LATEST_TAG=${LATEST_TAG}" >> $GITHUB_ENV  # Save for next steps
          sudo docker tag portfolio-backend $IMAGE_TAG  # Tag the local image
          sudo docker tag portfolio-backend $LATEST_TAG  # Tag the local image
          echo " Images tagged as: $IMAGE_TAG and $LATEST_TAG"  # Success message

      - name: Login to Docker registry  # Step 8: Login to Docker Hub (only runs if health check passed)
        run: |  # Multi-line shell script
          echo " Logging into Docker registry..."  # Status message
          echo "${{ secrets.DOCKER_PASSWORD }}" | sudo docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin  # Use secrets for authentication
          echo " Successfully logged into Docker registry"  # Success message

      - name: Push image to registry  # Step 9: Push images to Docker Hub (only runs if health check passed)
        run: |  # Multi-line shell script
          echo "ðŸ“¤ Pushing images to registry..."  # Status message
          sudo docker push $IMAGE_TAG  # Push versioned image
          sudo docker push $LATEST_TAG  # Push latest image
          echo " Images successfully pushed to registry!"  # Success message
          echo " Images available at:"  # Show URLs
          echo "  - $IMAGE_TAG"  # Shows the tagged image URL
          echo "  - $LATEST_TAG"  # Shows the latest image URL
