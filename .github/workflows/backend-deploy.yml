# GitHub Actions Workflow File
# This file defines an automated CI/CD pipeline that runs on GitHub's servers
# When you push code, it automatically builds, tests, and deploys your backend

# Display name shown in GitHub Actions UI
name: Deploy Backend to EC2

# WHEN does this workflow run?
on:
  push:  # Trigger on git push events
    # Only run when these files/folders change
    paths:
      - 'backend/**'  # Any file in backend/ folder
      - '.github/workflows/backend-deploy.yml'  # This workflow file itself
      - 'backend/Dockerfile'  # Docker build instructions
      - 'backend/requirements.txt'  # Python dependencies
      - 'backend/.env*'  # Environment variable files
      - '!frontend/**'  # EXCLUDE frontend changes (don't run for frontend)
    # Only run on pushes to these branches
    branches:
      - main  # Production branch

# WHAT jobs to run (can have multiple jobs, but we have one)
jobs:
  deploy:  # Job name
    # Run on YOUR EC2 server (not GitHub's servers)
    runs-on: self-hosted

    # STEPS to execute (run in order)
    steps:

      # Step 1: Get the code from GitHub
      - name: Checkout code  # Human-readable step name
        # Use GitHub's pre-built "checkout" action
        uses: actions/checkout@v4

      # Step 2: Create environment variables file
      - name: Create environment file
        # Multi-line shell script
        run: |
          # Go to backend folder on EC2
          cd /home/ec2-user/portfolio/backend
          # Create .env file with all secrets
          cat > .env << EOF
          MONGO_URL=${{ secrets.MONGO_URL }}  # Database connection (from GitHub Secrets)
          GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}  # AI API key
          SERPER_API_KEY=${{ secrets.SERPER_API_KEY }}  # Search API key
          CORS_ORIGINS=${{ secrets.CORS_ORIGINS }}  # Frontend URLs allowed to connect
          CHROMA_HOST=${{ secrets.CHROMA_HOST }}  # Vector database host
          CHROMA_API_KEY=${{ secrets.CHROMA_API_KEY }}  # Vector database key
          CHROMA_TENANT=${{ secrets.CHROMA_TENANT }}  # Vector database tenant
          CHROMA_DATABASE=Development  # Database name (hardcoded)
          CLOUDINARY_CLOUD_NAME=${{ secrets.CLOUDINARY_CLOUD_NAME }}  # Image hosting
          CLOUDINARY_API_KEY=${{ secrets.CLOUDINARY_API_KEY }}  # Image hosting key
          CLOUDINARY_API_SECRET=${{ secrets.CLOUDINARY_API_SECRET }}  # Image hosting secret
          DB_NAME=portfolioDB  # MongoDB database name
          ENVIRONMENT=production  # Tells app it's running in production
          EOF
          # Set file permissions (owner read/write only)
          chmod 600 .env

      # Step 3: Update vector database if portfolio data changed
      - name: Repopulate ChromaDB (if data files changed)
        run: |
          cd /home/ec2-user/portfolio/backend
          if git diff HEAD~1 HEAD --name-only | grep -E "(portfolio_data\.json|formatted_data\.json|fixed_data\.json)"; then
            # If portfolio data files changed, rebuild the vector database
            echo "üìã Data files changed - repopulating ChromaDB..."
            python3 populate_vector_db.py  # Run the database population script
            echo "‚úÖ ChromaDB repopulated successfully!"
          else
            # If no data files changed, skip this step
            echo "‚ÑπÔ∏è No data file changes detected - skipping ChromaDB repopulation"
          fi

      # Step 4: Build and deploy the Docker container
      - name: Deploy and restart backend
        run: |
          # Go to project root on EC2
          cd /home/ec2-user/portfolio
          # Get latest changes from GitHub
          git fetch origin main
          # Force update to latest commit
          git reset --hard origin/main
          # Stop/remove old container (ignore errors)
          sudo docker rm -f portfolio-backend || true
          # Build new image
          sudo docker build -t portfolio-backend -f backend/Dockerfile .
          # Run container: load env vars, map port 8000, name it, auto-restart, detached mode
          sudo docker run --env-file /home/ec2-user/portfolio/backend/.env -p 8000:8000 --name portfolio-backend --restart unless-stopped -d portfolio-backend

      # Step 5: Wait for container to start up
      - name: Wait for container to start
        run: |
          echo "Waiting for container to start..."
          # Wait 10 seconds for container to initialize
          sleep 10
          # Show last 50 lines of container logs
          sudo docker logs portfolio-backend --tail 50

      # Step 6: Test that the backend is working
      - name: Health check
        run: |
          echo "Running health check..."
          # Try up to 10 times
          max_attempts=10
          attempt=0
          while [ $attempt -lt $max_attempts ]; do
            if curl -f http://localhost:8000/ > /dev/null 2>&1; then
              # If curl succeeds (HTTP 200), backend is healthy
              echo "‚úÖ Backend is healthy!"
              # Success - exit the script
              exit 0
            fi
            echo "Attempt $((attempt+1))/$max_attempts failed, retrying..."
            # Wait 5 seconds before retrying
            sleep 5
            attempt=$((attempt+1))
          done
          echo "‚ùå Backend health check failed!"
          # Failure - stop the workflow
          exit 1

      # Step 7: Tag the Docker image for registry (only runs if health check passed)
      - name: Tag Docker image for registry
        run: |
          echo "üè∑Ô∏è Tagging image for registry..."
          # Get short commit hash for unique versioning
          COMMIT_SHA=$(git rev-parse --short HEAD)
          # Unique tag with commit
          IMAGE_TAG="kubealthaf/portfolio-backend:${COMMIT_SHA}"
          # Latest tag for easy pulling
          LATEST_TAG="kubealthaf/portfolio-backend:latest"
          # Save for next steps
          echo "IMAGE_TAG=${IMAGE_TAG}" >> $GITHUB_ENV
          echo "LATEST_TAG=${LATEST_TAG}" >> $GITHUB_ENV
          # Tag the local image
          sudo docker tag portfolio-backend $IMAGE_TAG
          sudo docker tag portfolio-backend $LATEST_TAG
          echo "‚úÖ Images tagged as: $IMAGE_TAG and $LATEST_TAG"

      # Step 8: Login to Docker Hub (only runs if health check passed)
      - name: Login to Docker registry
        run: |
          echo "üîê Logging into Docker registry..."
          # Use secrets for authentication (never expose passwords in code!)
          echo "${{ secrets.DOCKER_PASSWORD }}" | sudo docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          echo "‚úÖ Successfully logged into Docker registry"

      # Step 9: Push images to Docker Hub (only runs if health check passed)
      - name: Push image to registry
        run: |
          echo "üì§ Pushing images to registry..."
          # Push versioned image
          sudo docker push $IMAGE_TAG
          # Push latest image
          sudo docker push $LATEST_TAG
          echo "‚úÖ Images successfully pushed to registry!"
          echo "üñºÔ∏è Images available at:"
          echo "  - $IMAGE_TAG"  # Shows the tagged image URL
          echo "  - $LATEST_TAG"  # Shows the latest image URL
